name: Publish to NuGet

on:
  workflow_call:
    inputs:
      source:
        required: false
        type: string
        default: https://api.nuget.org/v3/index.json
        description: The NuGet server URL used by the `dotnet nuget push` command's `--source` argument. 
      verbosity:
        required: false
        type: string
        default: minimal
        description: The logging verbosity type used by the `dotnet` command.
    secrets:
      # We can't access org secrets here so they need to be passed in, see:
      # https://github.community/t/resuable-called-workflow-environment-variables-secrets-and-trigger-event-access/207723/2
      API_KEY:
        required: true

defaults:
  run:
    shell: pwsh

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Print Source
        shell: pwsh
        run: |
          $source = @'
          ${{ inputs.source }}
          '@.Trim()

          Write-Output "NuGet Source: $source"
          "SOURCE_URL=$source" >> $Env:GITHUB_ENV

      - name: Get the Version
        run: |
          $version = $Env:GITHUB_REF_NAME.Trim().Substring(1)
          Write-Output "Target Version: $version"
          "PUBLISH_VERSION=$version" >> $Env:GITHUB_ENV

      - uses: actions/checkout@v3

      - name: Set up .NET
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: 6.0.*

      - name: Add Source Link package
        shell: bash
        run: |
          # Never edit this on its own. First update and test the scripts/add-package.sh file, then
          # copy the `program` function here and call it with `program Microsoft.SourceLink.GitHub`.
          function program() {

              package_name="$1"

              function err() {
                  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*" >&2
              }

              function panic() {
                  error_code="$1"
                  shift

                  for line in "$@"; do
                      err "$line"
                  done

                  exit "$error_code"
              }

              function alter-solution() {
                  solution_file="$1"
                  [ -f "$solution_file" ] || panic 1 "Couldn't find the solution '$solution_file' in '$PWD'."

                  for project_path in $(dotnet sln "$solution_file" list | sed '1,2 D'); do
                      directory="$(dirname "$solution_file")/$(dirname "$project_path")"

                      pushd "$directory" || panic 2 "Couldn't open the project directory '$directory'."
                      alter-project "$(basename "$project_path")"
                      popd || panic 3 "Couldn't return to the original directory."
                  done
              }

              function alter-project() {
                  project_file="$1"
                  [ -f "$project_file" ] || panic 4 "Couldn't find the project '$project_file' in '$PWD'."

                  dotnet add "$project_file" package "$package_name"
              }

              if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
                  echo
                  basename "$0"
                  echo
                  echo "USAGE"
                  echo -e "\tbash $(basename "$0") package_name [solution.sln]\n"
                  echo "package_name - The name of a NuGet package. The same you'd pass to 'dotnet add package'."
                  echo "solution.sln - Optional argument to provide the path to the solution file. If none are"
                  echo "               provided then the script looks for .sln or if none found then for .??proj"
                  echo "               (i.e. csproj, fsproj, vbproj) in the current working directory."
              else
                  # The NuGetBuild property need to set so we don't get errors due to wrong references that are targeted at
                  # non-NuGet builds.
                  printf "<Project>\n  <PropertyGroup>\n    <NuGetBuild>true</NuGetBuild>\n  </PropertyGroup>\n</Project>" > Directory.Build.props

                  if [ -f "$2" ]; then
                      alter-solution "$2"
                  elif solutions=(./*.sln) && ((${#solutions[@]})) && [ -f "${solutions[0]}" ]; then
                      for solution in "${solutions[@]}"; do
                          alter-solution "$solution"
                      done
                  else
                      for project in ./*.??proj; do
                          alter-project "$project"
                      done
                  fi
              fi

          }
          program Microsoft.SourceLink.GitHub

      - name: Update package manifest version
        shell: pwsh
        run: |
            function Program {
                param(
                    [string]
                    $WorkDir,
                    [string]
                    $PackageVersion
                )

                function Update-Manifest-Version {
                    param(
                        [string]
                        $Manifest,
                        [string]
                        $Version
                    )

                    (Get-Content -Raw $Manifest) -replace 
                        '(?<head>\[assembly:\s*(Module|Theme)\(([^\]]*Version\W*=\W*"))([^"]*)', "`${head}$Version" |
                        Out-File $Manifest

                     Write-Output "Version updated in $Manifest to $Version"
                }

                $manifests = Get-ChildItem $WorkDir -File -Recurse -Filter "Manifest.cs" |
                    Select-String -List -Pattern '(OrchardCore.Modules.Manifest|OrchardCore.DisplayManagement.Manifest)' | 
                    Select-Object -ExpandProperty Path

                foreach ($manifest in $manifests) {
                    Update-Manifest-Version $manifest $PackageVersion
                }
            }

            Program './' $Env:PUBLISH_VERSION

      - name: Install dependencies
        run: dotnet restore -p:NuGetBuild=true --verbosity ${{ inputs.verbosity }}

      - name: Build
        # Notes on the configuration:
        # * -p:NuGetBuild=true is our property to load Lombiq dependencies from NuGet by switching project references
        #   to package references.
        # * -p:GenerateDocumentationFile=True is for generating XML doc files. Needed both for build and pack. It'd
        #   cause CS* warnings but we handle that centrally from .NET Analyzers so disabling them here.
        # * VSTHRD* rules come from somewhere unknown, disabling them.
        # * -p:EnableNETAnalyzers=false is to disable further .NET analyzer we don't need here.
        # * -p:ContinuousIntegrationBuild=true is needed for Deterministic Builds:
        #   https://github.com/clairernovotny/DeterministicBuilds.
        # * -p:DebugSymbols=true and -p:DebugType=portable are needed to generate PDB files.
        run: |
          $arguments = @(
              "--configuration:Release",
              "--no-restore",
              "--verbosity:${{ inputs.verbosity }}",
              "-p:NuGetBuild=true",
              "-p:LangVersion=Latest",
              "-p:GenerateDocumentationFile=True",
              "-p:NoWarn=CS1573%3BCS1591%3BVSTHRD002%3BVSTHRD200",
              "-p:EnableNETAnalyzers=false",
              "-p:ContinuousIntegrationBuild=true",
              "-p:DebugSymbols=true",
              "-p:DebugType=portable"
          )
          dotnet build @arguments

      - name: Pack
        # Notes on the configuration apart from what's also for dotnet build:
        # * NoWarn on NU5104 to not have warnings for prerelease dependencies, see:
        #   https://docs.microsoft.com/en-us/nuget/reference/errors-and-warnings/nu5104.
        # * -p:WarnOnPackingNonPackableProject=True will cause a build warning (converted to error) if we try to pack
        #   a non-packagable project.
        # * -p:IncludeSymbols=true -p:SymbolPackageFormat=snupkg are needed to generate symbol packages:
        #   https://docs.microsoft.com/en-us/nuget/create-packages/symbol-packages-snupkg.
        run: |
          $arguments = @(
              "--configuration:Release",
              "--warnaserror",
              "--no-restore",
              "--no-build",
              "--output:artifacts",
              "--verbosity:${{ inputs.verbosity }}",
              "-p:NuGetBuild=true",
              "-p:Version=$Env:PUBLISH_VERSION",
              "-p:GenerateDocumentationFile=True",
              "-p:NoWarn=NU5104",
              "-p:TreatWarningsAsErrors=true",
              "-p:WarnOnPackingNonPackableProject=True",
              "-p:IncludeSymbols=true",
              "-p:SymbolPackageFormat=snupkg",
              "-p:NoDefaultExcludes=true"
          )
          dotnet pack @arguments   

      - name: Push with dotnet
        run: dotnet nuget push artifacts/*.nupkg --api-key ${{ secrets.API_KEY }} --source $Env:SOURCE_URL --skip-duplicate

      - name: Publish Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: NuGet-Package
          path: artifacts

      # This is not in its own action becasuse it's all very specific to this NuGet publishing workflow.
      - name: Create Release
        # v1.10.0
        uses: ncipollo/release-action@58ae73b360456532aafd58ee170c045abbeaee37
        # This is to prevent creating releases when pushing tags for issue-specific pre-releases like
        # v4.3.1-alpha.osoe-86.
        if: "!contains(github.ref, '-')"
        with:
          allowUpdates: true
          generateReleaseNotes: true
          artifacts: artifacts/*.nupkg, artifacts/*.snupkg
