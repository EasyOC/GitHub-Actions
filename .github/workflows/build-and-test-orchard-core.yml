name: Build and Test Orchard Core

on:
  workflow_call:
    inputs:
      # This needs to be stringified JSON because inputs don't support arrays, see 
      # https://github.community/t/reusable-workflow-with-strategy-matrix/205676/2.
      machine-types:
        required: false
        type: string
        default: "[\"ubuntu-latest\"]"
        description: >
            Stringified JSON array with the name of the type of machine(s) to run the workflow under, e.g.
            "[\"ubuntu-latest\"]" or "[\"ubuntu-latest\", \"windows-latest\"]". Defaults to "[\"ubuntu-latest\"]".
      dotnet-version:
        required: false
        type: string
        default: 6.0.*
        description: >
          Version of the .NET SDK to set up. Defaults to 6.0.*.
      build-directory:
        required: false
        type: string
        default: .
        description: Path to the directory where a solution file can be found. Defaults to ".".
      build-verbosity:
        required: false
        type: string
        default: quiet
        description: Verbosity parameter for dotnet build. Defaults to "quiet".
      timeout-minutes:
        required: false
        type: number
        default: 360
        description: Configuration for the timeout-minutes parameter of the workflow. Defaults to 360.

jobs:
  build-and-test:
    runs-on: ${{ matrix.machine-type }}
    name: Build and Test
    # Timeout-minutes is in the matrix only because the config can't be set directly from the inputs, see:
    # https://github.com/actions/runner/issues/1555.
    strategy:
      matrix:
        machine-type: ${{fromJson(inputs.machine-types)}}
        timeout-minutes: [${{ inputs.timeout-minutes }}]
    timeout-minutes: ${{ matrix.timeout-minutes }}
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: 'recursive'

    - name: Set up .NET
      uses: Lombiq/GitHub-Actions/.github/actions/setup-dotnet@issue/NEST-314
      with:
        dotnet-version: ${{ inputs.dotnet-version }}

    - name: Build and Static Code Analysis
      uses: Lombiq/GitHub-Actions/.github/actions/build-with-code-analysis@issue/NEST-314
      with:
        build-directory: ${{ inputs.build-directory}}
        build-verbosity: ${{ inputs.build-verbosity}}

    - name: Set up SQL Server
      shell: pwsh
      run: |
        if ($Env:RUNNER_OS -eq "Windows")
        {
            choco install sql-server-express --no-progress
        }
        else
        {
            docker pull mcr.microsoft.com/mssql/server &&
            docker run --name sql2019 -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Password1!' -p 1433:1433 -d 'mcr.microsoft.com/mssql/server:2019-latest' &&
            docker exec -u 0 sql2019 bash -c 'mkdir /data; chmod 777 /data -R; chown mssql:root /data'
        }

    # Needs to be a separate step, otherwise the Chocolatey installation won't be visible.
    - name: Wait for SQL Server to start
      shell: pwsh
      run: |
        $maxTryCount = 10

        for ($i = 1; $i -le $maxTryCount; $i++)
        {
            echo "Waiting for SQL Server to start. Attempt $i/$maxTryCount."

            if ($Env:RUNNER_OS -eq "Windows")
            {
                sqlcmd -b -S .\SQLEXPRESS -Q "SELECT @@SERVERNAME as ServerName" 2>&1>$null
            }
            else
            {
                sqlcmd -b -U sa -P 'Password1!' -Q "SELECT @@SERVERNAME as ServerName" 2>&1>$null
            }

            if ($?)
            {
                echo "SQL Server is successfully started."
                Exit 0
            }

            if ($i -eq $maxTryCount)
            {
                echo "SQL Server couldn't be started."
                Exit 1
            }

            echo "SQL Server is not ready. Waiting 1 second."
            Start-Sleep -s 1
        }

    - name: Set up Azurite via NPM
      # This needs to run in bash for some reason. Azurite properly starts in PS but still, connections fail.
      shell: bash
      run: |
        npm install -g azurite
        azurite --silent --location ${{inputs.build-directory}}/azurite --debug ${{inputs.build-directory}}/azurite/debug.log &

    # First, we globally set test configurations using environment variables. Then acquire the list of all test projects
    # (excluding the two test libraries) and then run each until one fails or all concludes. If a test fails, the output
    # is sanitized from unnecessary diagnostics messages from chromedriver if the output doesn't already contain
    # groupings, then it wraps them in '::group::<project name>'. If there are already groupings, then it is not
    # possible to nest them (https://github.com/actions/runner/issues/802) so that's omitted. The groupings make the
    # output collapsible region on the Actions web UI. Note that we use bash to output the log using bash to avoid pwsh
    # wrapping the output to the default buffer width.
    - name: Tests
      shell: pwsh
      working-directory: ${{ inputs.build-directory }}
      run: |
        function Configure-Environment($hash) { Set-Item @hash }

        if ($Env:RUNNER_OS -eq "Windows")
        {
            Configure-Environment @{
                Path = 'Env:\Lombiq_Tests_UI__SqlServerDatabaseConfiguration__ConnectionStringTemplate'
                Value = 'Server=.\SQLEXPRESS;Database=LombiqUITestingToolbox_{{id}};Integrated Security=True;MultipleActiveResultSets=True;Connection Timeout=60;ConnectRetryCount=15;ConnectRetryInterval=5'
            }
        }
        else
        {
            Configure-Environment @{
                Path = 'Env:\Lombiq_Tests_UI__SqlServerDatabaseConfiguration__ConnectionStringTemplate'
                Value = 'Server=.;Database=LombiqUITestingToolbox_{{id}};User Id=sa;Password=Password1!;MultipleActiveResultSets=True;Connection Timeout=60;ConnectRetryCount=15;ConnectRetryInterval=5'
            }
            Configure-Environment @{
                Path = 'Env:\Lombiq_Tests_UI__DockerConfiguration__ContainerName'
                Value = 'sql2019'
            }
        }

        $tests = dotnet sln list |
            Select-Object -Skip 2 |
            Select-String '\.Tests\.' |
            Select-String -NotMatch 'Lombiq.Tests.UI.csproj' |
            Select-String -NotMatch 'Lombiq.Tests.csproj' |
            ? {
                $result = dotnet test --no-restore --list-tests --verbosity ${{ inputs.build-verbosity }} $_ 2>&1 | Out-String -Width 9999
                -not [string]::IsNullOrEmpty($result) -and $result.Contains('The following Tests are available')
            }

        foreach ($test in $tests) {
            dotnet test -c Release --no-restore --no-build --nologo --logger "trx;LogFileName=test-results.trx" --verbosity ${{ inputs.build-verbosity }} $test 2>&1 >test.out

            if ($?)
            {
                echo "Test Successful: $test"
                continue
            }

            $needsGrouping = (Select-String '::group::' test.out).Length -eq 0

            if ($needsGrouping) { echo "::group::Test Failed: $test" }

            bash -c "cat test.out | grep -v 'Connection refused \[::ffff:127.0.0.1\]' | grep -v 'ChromeDriver was started successfully'"

            if ($needsGrouping) { echo "::endgroup::" }

            exit 100
        }

    # Note that this would fail under Windows if the path is too long, regardless of LongPathsEnabled, see:
    # https://github.com/actions/upload-artifact/issues/309. To get around that we merge all FailureDumps into the
    # solution root. The following two steps need to be success() || failure() (excluding the workflow being
    # cancelled), so if there's a failure dump it'll be uploaded even if the tests are ultimately passed after retries.
    # The same is true for the next step as well.
    - name: Merge FailureDumps
      shell: pwsh
      if: success() || failure() && hashFiles(format('{0}/test/**/FailureDumps', inputs.build-directory))
      run: |
        New-Item -Type Directory "${{inputs.build-directory}}/FailureDumps"
        Get-ChildItem "${{inputs.build-directory}}/test" -Recurse |
          ? { $_.Name -eq 'FailureDumps' } |
          % { $_.GetDirectories() } |
          % { Move-Item $_.FullName "${{inputs.build-directory}}/FailureDumps/${_.Name}" }

    - name: Upload UI testing artifacts
      uses: actions/upload-artifact@v3
      # We don't need additional conditions, because of the "if-no-files-found" setting.
      if: success() || failure()
      with:
        name: ui-test-failure-dump-${{ inputs.build-directory }}-${{ matrix.machine-type }}
        path: |
          ${{ inputs.build-directory }}/FailureDumps/
          test.out
        if-no-files-found: ignore

    - name: Test Report
      uses: phoenix-actions/test-reporting@v8
      if: success() || failure()
      with:
        name: Test Results (${{inputs.build-directory}} ${{ matrix.machine-type }})
        path: '${{inputs.build-directory}}/**/*.trx'
        reporter: dotnet-trx
        fail-on-error: 'false'
